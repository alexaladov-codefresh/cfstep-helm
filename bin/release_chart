#!/bin/sh
set -e

msg() { echo -e "INF---> $1"; }
err() { echo -e "ERR---> $1" ; exit 1; }

# process repo contexts
processRepoContexts() {
	local vars=$(env | awk -F '=' '{print $1}' | grep -iE "^CF_CTX_[^_].+_URL")

	for var in $vars
	do
		local varValue=$(eval "echo \$$var")
		repoName=$(echo $var | sed -rn 's/^CF_CTX_([^_].+)_URL.*/\1/p')
		# Handle basic auth
		if [ ! -z "${HELMREPO_USERNAME}" ] ; then
			msg "Adding basic auth to REPO URL"
			varValue=$(echo $varValue | sed -rn 's/(https?:\/\/)(.*)/\1'"${HELMREPO_USERNAME}"':'"${HELMREPO_PASSWORD}"'@\2/p')
		fi
		msg "adding repo $repoName : $varValue"
		helm repo add $repoName $varValue
		msg "REPO_URL set to $varValue"
		CHART_REPO_URL=$varValue
	done
}

# process custom variables
processCustomVals() {
	local resultedArgs=""

	local vars=$(env | awk -F '=' '{print $1}' | grep -i "^customFile_")
	for var in $vars
	do
		local varValue=$(eval "echo \$$var")
		resultedArgs="$resultedArgs --values $varValue"
	done

	local vars=$(env | awk -F '=' '{print $1}' | grep -i "^custom_")
	for var in $vars
	do
		local varName=$(echo $var | sed 's/^custom_//gI' | sed 's/_/./g' | sed 's/\.\./_/g')
		local varValue=$(eval "echo \$$var")
		resultedArgs="$resultedArgs --set $varName=$varValue"
	done

	echo "$resultedArgs"
}

fixGcsContext() {
	msg "Adding Google creds variable"
	echo -E $GOOGLE_APPLICATION_CREDENTIALS_JSON > /tmp/google-creds.json
	export GOOGLE_APPLICATION_CREDENTIALS="/tmp/google-creds.json"
}

# get chart name (required)
if [ -z "$CHART_NAME" ]; then
  err "Please, specify Helm Chart with CHART_NAME environment variable"
  exit 1
fi
chart="${CHART_NAME}"

# get release name (required)
#TODO: optional
if [ -z "$RELEASE_NAME" ]; then
  err "Please, specify Helm Release name with RELEASE_NAME environment variable"
  exit 1
fi
release="${RELEASE_NAME}"

#TODO: optional
if [ -z "$KUBE_CONTEXT" ]; then
  err "Please, set Kubernetes context. Use name from Codefresh Integrations page."
else
  msg "Using ${KUBE_CONTEXT} context"
  kubectl config use-context ${KUBE_CONTEXT}
fi

customVals=$(processCustomVals)

# Workround for GCS. Should be fixed with new pluggable context
if [ ! -z "${GOOGLE_APPLICATION_CREDENTIALS_JSON}" ] ; then
	fixGcsContext
fi
processRepoContexts


# target namespace
# TODO: leave it to helm to choose deafult ns
# TODO: take from context
if [ ! -z "${NAMESPACE}" ]; then
namespace="--namespace=${NAMESPACE}"
fi

# TILLER_NAMESPACE is set as env var to helm.
# TODO: take from context

# set chart version flag
if [ ! -z "${CHART_VERSION}" ]; then
  version="--version ${CHART_VERSION}"
fi

# set chart repo flag
if [ ! -z "${CHART_REPO_URL}" ]; then
  repoUrl="--repo ${CHART_REPO_URL}"
else #if installing from local, "unpacked" chart, then restore dependencies first
  msg "Building dependencies"
  helm dependency build $chart
fi

#if ACTION is set to push, perform chart pushing instead of deploying
if [ $ACTION == 'push' ]
then
	msg "Packaging the chart..."
	PACKAGE=$(helm package $chart $version --destination /dev/shm/ | cut -d " " -f 8)

#switch between different types of repositories
	case $CHART_REPO_URL in
		s3*)
			msg "Pushing the chart to s3 bucket..."
	    		helm s3 push $PACKAGE $repoName && msg "Successfully pushed" || msg "Push failed"
			;;
		gs*)
			msg "Pushing the chart to GCS bucket..."
			helm gcs push $PACKAGE $repoName && msg "Successfully pushed" || msg "Push failed"
			;;
	esac
else
	msg "Installing chart"
	helmCmd="helm upgrade $release $chart --install $repoUrl $version $customFlags --force --reset-values $namespace $customVals $CMD_PS"
	msg "$helmCmd"
	eval "$helmCmd"
fi
